# HTTP 기본

## 모든 것이 HTTP

#### HTTP(HyperText Transfer Protocol)

-   HTTP 메시지에 모든 것을 전송
-   HTML, TEXT
-   IMAGE, 음성, 영상, 파일
-   JSON, XML(API)
-   거의 모든 형태의 데이터 전송 가능
-   서버 간에 데이터를 주고 받을 때 대부분 HTTP 사용

#### HTTP 역사

-   HTTP/0.9: 1991년 GET 메서드만 지원, HTTP 헤더 X
-   HTTP/1.0: 1996년 메서드, 헤더 추가
-   **HTTP/1.1: 1997년 가장 많이 사용, 가장 중요한 버전**
    -   RFC2068(1997) → RFC2616(1999) → RFC7230 ~ 7235(2014)
-   HTTP/2: 2015년 성능 개선
-   HTTP/3 진행 중: TCP 대신에 UDP 사용, 성능 개선

#### 기반 프로토콜

-   TCP: HTTP/1.1, HTTP/2
-   UDP: HTTP/3
-   크롬 브라우저 network 탭에서 protocol 항목으로 확인 가능
    -   HTTP/1.1 → http/1.1
    -   HTTP/2 → h2
    -   HTTP/3 → h3-29

#### HTTP 특징

-   클라이언트 서버 구조
-   무상태 프로토콜(Stateless), 비연결성
-   HTTP 메시지
-   단순함, 확장 가능

## 클라이언트 서버 구조

#### 클라이언트 서버 구조

-   Request, Response 구조
-   클라이언트는 서버에 요청을 보내고, 응답을 대기
-   서버가 요청에 대한 결과를 만들어서 응답

#### 클라이언트와 서버를 분리하는 것이 중요한 이유

-   비즈니스 로직이랑 데이터 같은 것은 서버에서 처리
-   클라이언트는 UI, UX에만 집중
-   클라이언트와 서버가 각각 독립적으로 진화할 수 있음
-   트래픽이 늘어도 클라이언트룰 수정하는 것이 아니라 서버를 발전시키면 됨

## 무상태 프로토콜

#### Stateless(무상태)

-   서버가 클라이언트의 상태 보존 X
-   로그인한 사용자의 경우 로그인 했다면 상태를 서버에 유지해야 함 → 일반적으로 브라우저 쿠키 와 서버 세션 등을 사용해서 상태 유지
-   장점: 서버 확장성 높음(스케일 아웃 → 무한한 서버 증설 가능)
-   단점: 클라이언트가 추가 데이터 전송

#### Stateful(상태 유지)

-   서버가 클라이언트의 이전 상태 보존
-   항상 같은 서버가 유지되어야 함.
-   중간에 서버가 상태가 나면 처음부터 다시 진행해야 함.

## 비 연결성(connectionless)

#### 연결을 유지하는 모델

-   클라이언트가 서버에 접속해서 요청을 보내고 응답을 받은 뒤에도 연결을 유지하는 경우 클라이언트의 요청이 없을 때도 연결을 유지하는 서버의 자원이 계속 소모됨.

#### 연결을 유지하지 않는 모델

-   클라이언트가 서버에 접속해서 요청을 보내고 응답을 받으면 서버와 연결을 끊음. 요청이 필요할 때마다 클라이언트와 서버가 연결을 맺고 끊음을 반복함. 서버는 불필요하게 유지되는 자원을 최소한으로 줄일 수 있음.

#### 비 연결성

-   HTTP는 기본적으로 연결을 유지하지 않는 모델
-   일반적으로 초 단위 이하의 빠른 속도로 응답
-   서버 자원을 매우 효율적으로 사용할 수 있음
-   단점:
    -   TCP/IP 연결을 매번 새로 맺어야 함. → 3-way handshake 시간 추가
    -   웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 자바스크립트, css 등 수 많은 자원이 함께 다운로드 됨
    -   HTTP/1.1에서는 HTTP 지속 연결(Persistent Connection)로 문제 해결
    -   HTTP/2, HTTP/3에서 더 많은 최적화

#### HTTP 지속 연결

-   모든 리소스를 요청할 때마다 연결, 요청, 종료를 반복하는 것이 아니라, 한 번 연결한 뒤에 모든 리소스를 요청할 때까지 유지하고 종료함.

#### 대용량 트래픽 대응 방안

-   선착순 이벤트, 명절 KTX 예약 등 대용량 트래픽이 발생하는 경우에는 첫 페이지에 로그인도 필요없는 순수 HTML 정적 페이지를 하나 둔다. 해당 HTML에 이벤트 참여 버튼을 누르게 하는 식으로 해결한다. 무상태로 해결할 수 있는 부분은 최대한 무상태로 처리하고, 어쩔 수 없는 부분에 한해서만 상태 유지를 하로도록 잘 분리해서 설계하는 것이 중요하다.

## HTTP 메시지

#### HTTP 메시지 구조

-   start-line: 시작 라인
-   header: 헤더
-   empty line: 공백 라인(CRLF) - 필수
-   message body

#### 시작 라인

-   start-line = request-line(요청) / status-line(응답)
    -   request-line = method SP(공백) request-target SP HTTP-version CRLF(엔터)
        -   method: HTTP 메서드(GET, POST, PUT, DELETE...), 서버가 수행해야 할 동작 지정
        -   request-target: 요청 대상, 절대경로[?쿼리], 절대경로는 "/"로 시작하는 경로
        -   HTTP-version: HTTP 버전
    -   status-line = HTTP-version SP status-code SP reason-phrase CRLF
        -   HTTP-version: HTTP 버전
        -   status-code: HTTP 상태 코드 → 요청 성공, 실패를 나타냄
            -   200: 성공
            -   400: 클라이언트 요청 오류
            -   500: 서버 내부 오류
        -   reason-phrase: 이유 문구 → 사람이 이해할 수 있는 짧은 상태 코드 설명 글

#### HTTP 헤더

-   header-field = filed-name ":" OWS field-value OWS (OWS: 띄어쓰기 허용)
-   field-name은 대소문자 구분 없음
-   HTTP 전송에 필요한 모든 부가정보
    -   메시지 바디의 내용
    -   메시지 바디의 크기
    -   압축
    -   인증
    -   요청 클라이언트(브라우저) 정보
    -   서버 애플리케이션 정보
    -   캐시 관리 정보
-   표준 헤더가 많음
-   필요 시 임의의 헤더 추가 가능

#### HTTP 메시지 바디

-   실제 전송할 데이터
-   HTML 문서, 이미지, 영상, JSON 등 byte로 표현할 수 있는 모든 데이터 전송 가능
